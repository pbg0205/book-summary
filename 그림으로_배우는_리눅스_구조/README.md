# 그림으로 배우는 리눅스 구조

## chapter01. 리눅스 개요

### 1. 프로그램과 프로세스

- 프로그램 : 컴퓨터에서 동작하는 관련된 명령 및 데이터를 하나로 묶은 것 (커널도 프로그램 일종)
- 프로세스 : 실행되어서 동작 중인 프로그램

### 2. 커널

1. 커널 : 커널 모드로 동작하면서 저장 장치 접근 제어, 시스템 자원 관리 및 배분 기능을 제공하는 S/W
2. 프로세스는 커널을 통해서 간접적으로 장치에 접근한다.
    - 프로세스가 직접 저장 장치에 접근하면 데이터 손상 및 접근 제어에 관한 문제가 있음.

### 3. 시스템 콜

1. 프로세스가 커널에 처리를 요청하는 방법이다. 시스템 콜이 호출하면 CPU 에서는 예외(exception) 이라는 이벤트가 발생한다.
2. 이를 계기로 CPU 모드가 사용자 모드에서 커널 모드로 바뀌고 요청 내용에 따라 커널 처리가 동작한다.
   시스템 콜 처리가 끝나면 또다시 사용자 모드로 돌아와서 프로세스 동작이 이어진다.

<br>

`strace -o <출력 결과 저장 파일> <실행 파일>`

- 어떤 시스템 콜이 호출하는지 확인하는 명령어
- option
    - -o  : 출력 결과를 파일로 저장 가능
    - -T : 시스템 콜 처리에 걸린 시간을 micro second 수준으로 정밀하게 측정

```bash
## hello.py 프로그램의 시스템 콜을 hello.log 에 저장하는 명령어
$ strace -o hello.log ./hello.py
```

<br>

`sar -P <논리 CPU 번호> <수집 간격> <수집 횟수>`

- 시스템 통계 정보를 나타내는 명령어
- 논리 CPU 가 실행하고 있는 명령 비율 확인 가능함

```bash
## -P 0 : 논리 CPU 0 의 데이터를 수집한다는 옵션
## 1 : 1초마다 수집한다
## 1 : 한 번만 데이터를 수집한다
$ sar -P 0 1 1
```

<br>

`taskset -c <논리 CPU 번호> <명령어>`

- 명령어 인수로 지정한 명령어를 지정한 CPU 에서 실행한다.

```bash
$ tasklet -c 0 ./inf-loop.py &
$ sar -c 0 1 1
```

<br>

3. 라이브러리 : 여러 프로그래밍 언어는 다수의 프로그램에서 공통으로 사용하는 처리를 라이브러리로 합쳐서 제공
    - 표준 C 라이브러리 : 표준 라이브러리로 glib(libc) 사용한다. 대부분의 C 프로그램은 libc 링크(linking).

<br>

`ldd <명령어>`

- 어떤 라이브러리를 링크하는지 확인하는 명령어

```bash
$ ldd /bin/bash
```

<br>

4. 시스템 콜 래퍼 함수
    - 시스템 콜은 일반 함수 호출과는 다르게 C 언어와 같은 고급 언어에서는 직접 호출 할 수 없다.
    - 아키텍처에 의존하는 어셈블리 코드를 사용해 호출해야 한다.
    - lib 는 내부적으로 시스템 콜을 호출할 뿐인 시스템 콜 래퍼 함수를 제공한다.
        - 아키텍처 별로 존재 : x86_64, arm64

<br>

5. 정적 라이브러리와 공유 라이브러리
    - 정적 라이브러리 : 링크할 떄 라이브러리에 있는 함수를 프로그램에 집어 넣는다.
        - 장점
            1. 요즘 H/W 스펙에는 파일 크기 문제가 크지 않음
            2. 실행 파일 하나로 프로그램이 동작해 파일 복사 시 다른 환경에서 동작
            3. 공유 라이브러리를 링크하지 않아 시작 시간이 빠름
            4. 공유 라이브러리의 DLL 지옥 회피 (버전업하면 일부 프로그램이 동작하지 않는 문제)
    - 공유 라이브러리 : 프로그램 시작이나 실행 중에 라이브러리를 메모리에 로드하고 프로그램은 그 안에 있는 함수를 호출한다.
        - 장점
            1. 시스템 차지하는 크기 절약
            2. 수정 버전 교체 시 해당 라이브러리 사용 모든 프로그램 문제 수정 가능

<br>

## chapter02. 프로세스 관리

`ps -aux`

- 시스템에 존재하는 모든 프로세스 확인

<br>

1. fork(), execve()
    - 리눅스에서 실행하는 프로세스를 생성하는데 사용하는 명령어
    - 내부적으로는 fork() 에는 clone(), execve() 는 exeve() 시스템 콜이 호출됨

<br>

2. fork()
    - 해당 프로세스의 복사본을 만드는 명령어
    - 과정
        1. 부모 프로세스 fork() 호출
        2. 자식 프로세스용 메모리 영역 확보한 후 부모 프로세스이 메모리를 복사
        3. 부모, 자식 프로세스 모두 fork() 함수에서 복귀
            - fork() 함수 복귀 시, 부모 프로세스는 자식 프로세스 ID, 자식 프로세는 0 을 반환

<br>

3. execve()
    - 프로세스의 메모리를 치환하는 명령어
    - 자식 프로세스는 fork() 함수 호출 이후 execve() 함수를 호출
    - 커널이 실행 파일을 읽어 프로세스 메모리를 치환 및 새로운 프로세스를 실행한다.
    - 과정
        1. execve() 함수 호출
        2. execve() 함수 인수로 지정한 실행 파일에서 프로그램을 읽어서 메모리에 배치하는데 밀요한 정보를 가져옴
        3. 현재 프로세스의 메모리를 새로운 프로세스 데이터로 덮어 씀
        4. 프로세스를 새로운 프로세스의 최초로 실행할 명령부터 실행하기
    - execve() 가 동작하기 위한 데이터들
        - 코드, 데이터 영역의 파일 오프셋, 크기, 메모리 맵 시작 주소
        - 최초로 실행할 명령의 메모리 주소 (엔트리 포인트)
            - `readlf`
                - -h : 프로그램 시작 주소 확인 커맨드
                - -S : 코드 , 데이터 파일 오프셋, 크기, 시작 주소 확인 (.txt : 코드 / .data : 데이터)

<br>

4. 프로세스의 부모, 자식 관계 : tree 구조

`ptree -p`

- 프로세스의 부모 자식 관계를 트리 구조로 표시
- -p option : PID 표시 옵션

<br>

5. 프로세스 상태 (ps aux 명령어의 STAT 필드)
    - 슬립 상태 : S
    - 실행 가능 상태 : R
    - 실행 상태
    - 좀비 상태 : Z

<br>

6. 프로세스 종료
    - 프로세스를 종료하려면 exit_group() 시스템 콜을 호출
    - 프로세스가 종료하면 부모 크로세스는 wait(), waitpid() 시스템 콜을 호출한다.
        - 회득 정보들 : **프로세스 반환 값**, **시그널에 따라 종료했는지 여부**, **종료할 떄까지 얼마나 CPU 시간을 사용했는지**
    - bash 에 저장된 wait 명령어 사용 시, 백그라운드로 실행 중인 프로세스에 wait() 시스템 콜을 호출해 프로세스 종료 상태를 얻을 수 있다.

<br>

7. 좀비 프로세스, 고아 프로세스
    - 좀비 프로세스
        - 종료했지만 부모 프로세스가 종료 상태를 확인하지 않은 상태의 프로세스
        - 부모 프로세스는 자식 프로세스 종료 상태를 제때 회수해 남아 있는 자원을 커널로 돌려줘야 한다.
    - 고아 프로세스
        - wait() 계열 시스템 콜을 실행하기 이전 부모 프로세스가 졸료되는 경우의 해당 프로세스
        - 커널은 init 를 고아 프로세스의 새로운 부모로 지정 (좀비도 부모 프로세스 종료시 init 을 부모로 지정)
            - init 은 주기적인 wait() 계열 시스템 콜을 통해 시스템 자원 회수

<br>

8. 시그널
    - 어떤 프로세스가 다른 프로세스에 더떤 신호를 보내 외부에서 실행 순서를 강제로 변경하는 방법
    - 프로세스는 각 시그널에 시그널 핸들러를 미리 등록한다.
    - 예시 (man 7 signal)
        - SIGINT : SIGINT signal 을 받은 프로세스는 곧바로 종료가 기본값
        - SIGCHLD : 자식 프로세스 종료 시 부모 프로세스에 보내는 시그널 (보통은 시그널 핸들러 내부에서 wait 계열 시스템 콜 호출)
        - SIGSTOP : 프로세스 실행을 일시적으로 정지
        - SIGCONT : SIGSTOP 등의 정지한 프로세스 실행 재개

<br>

9. 셸 작업 관리 구현 (세션 & 프로세스 그룹)
    1. 세션 : 사용자가 terminal emulator 또는 ssh 등을 사용해 시스템에 로그인 했을 떄에 대응하는 계념
        - 각 세션은 `pty/<n>` 이름이 붙은 가상 단말이 할당됨
        - 세션에 할당된 단말이 연결이 끊기는 경우 SIGHUP 시그널이 전달되어 bash 는 작업하던 작업 및 본인 종료
            - nohup : SIGHUP 을 무시하도록 설정하여 프로세스 기동
            - bash 의 disown 내장 명령어 : 실행 중인 작업을 bash 대상에서 제외
        - `ps ajx`: 프로세스의 세션 관련 정보 확인 가능
    2. 프로세스 그룹 : 여러 프로세스를 하나로 묶어서 한꺼번에 관리
       - 포그라운드 프로세스 그룹 : 셸의 포그라운드 작업에 대응. 세션당 하나만 존재하고 세션 단말에 직접 접근 가능
       - 백그라운드 프로세스 그룹 : 셸의 백그라운드 작업에 대응. 

<br>

10. 데몬
    - 시스템 시작부터 종료할 떄까지 계속해서 존재 및 실행
    - 특징
      - 단말의 입출력 필요 없기 떄문데 단말이 할당되지 않음
      - 로그인 세션을 종료해도 영향을 받지 않도록 독자적인 세션을 가짐
      - 데몬을 생성한 프로세스가 데몬 종료 여부를 신경 쓸 필요없이 init 가 부모가 됨
